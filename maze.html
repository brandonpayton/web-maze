<html>
<head>
</head>
<body>
    <div id="container" style="position: relative"></div>

    <script src="dojo/dojo.js"></script>
    <script>

        require(
            [ "dojo/query", "dojo/dom-construct", "dojo/dom-attr", "dojo/dom-style", "Maze" ],
            function(query, domConstruct, domAttr, domStyle, Maze) {
                var horizontalCells = 100,
                    verticalCells = 40,
                    cellPixels = 10,
                    width = horizontalCells * cellPixels,
                    height = verticalCells * cellPixels,
                    canvas = domConstruct.create("canvas", {
                        width: width,
                        height: height
                    }),
                    pathCanvas = domConstruct.create("canvas", {
                        width: width,
                        height: height
                    }),
                    container = query("#container")[0];

                domStyle.set(pathCanvas, {
                    "position": "absolute",
                    "top": 0,
                    "left": 0,
                    "zIndex": -1
                });

                container.appendChild(pathCanvas);
                container.appendChild(canvas);

                var m = new Maze({ wide: horizontalCells, high: verticalCells });
                var ctx = canvas.getContext('2d');

                ctx.lineWidth = 1;
                ctx.fillStyle = "blue";
                ctx.strokeRect(0, 0, horizontalCells * cellPixels, verticalCells * cellPixels);
                ctx.beginPath();
                var row, column, x, y;
                for(row = 0; row < m.high; row++) {
                    for(column = 0; column < m.wide; column++) {
                        x = column * cellPixels;
                        y = row * cellPixels;
                        if(!m.canGoDown(row, column)) {
                            ctx.moveTo(x, y + cellPixels);
                            ctx.lineTo(x + cellPixels, y + cellPixels);
                        }
                        if(!m.canGoRight(row, column)) {
                            ctx.moveTo(x + cellPixels, y);
                            ctx.lineTo(x + cellPixels, y + cellPixels);
                        }
                    }
                }
                ctx.stroke();
                ctx.closePath();

                var pctx = pathCanvas.getContext('2d');
                
                var visitedCells = [ ]
                for(var i = 0; i < verticalCells; i++) { visitedCells[i] = [] }

                function getNextCell(row, column) {
                    var accessibleNeighbors = m.getAccessibleNeighbors(row, column);
                    var options = accessibleNeighbors.reduce(function(unvisitedNeighbors, neighbor) {
                        if(!visitedCells[neighbor.row][neighbor.column]) unvisitedNeighbors.push(neighbor)
                        return unvisitedNeighbors
                    }, [])
                                       
                    return options.length === 0
                        ? null
                        : options[Math.floor(Math.random() * options.length)]
                }

                var cellStack = [ { row: 0, column: 0 } ];
                var intervalId = setInterval(function() {
                    try {
                        if(cellStack.length === 0) {
                            clearInterval(intervalId);
                        } else {
                            var c = cellStack[cellStack.length - 1];

                            if(visitedCells[c.row][c.column]) {
                                pctx.fillStyle = "orange";
                            } else {
                                visitedCells[c.row][c.column] = true;
                                pctx.fillStyle = "lightblue";
                            }
                            pctx.fillRect(c.column * cellPixels, c.row * cellPixels, cellPixels, cellPixels);

                            if(c.row === verticalCells - 1 && c.column === horizontalCells - 1) {
                                clearInterval(intervalId);
                                return;
                            }
                            var next = getNextCell(c.row, c.column);
                            if(next === null) {
                                pctx.fillStyle = "orange";
                                pctx.fillRect(c.column * cellPixels, c.row * cellPixels, cellPixels, cellPixels);
                                cellStack.pop();
                            } else {
                                cellStack.push(next);
                            }
                        }
                    } catch (e) {
                        clearInterval(intervalId);
                        throw e;
                    }
                }, 0);
            }
        );

    </script>

</body>
</html>
